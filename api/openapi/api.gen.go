// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ConditionOperator.
const (
	Equals             ConditionOperator = "equals"
	GreaterThan        ConditionOperator = "greater_than"
	GreaterThanOrEqual ConditionOperator = "greater_than_or_equal"
	LessThan           ConditionOperator = "less_than"
	LessThanOrEqual    ConditionOperator = "less_than_or_equal"
)

// Defines values for ExecutionStepStatus.
const (
	ExecutionStepStatusCompleted ExecutionStepStatus = "completed"
	ExecutionStepStatusFailed    ExecutionStepStatus = "failed"
	ExecutionStepStatusSkipped   ExecutionStepStatus = "skipped"
)

// Defines values for WorkflowExecutionResultStatus.
const (
	WorkflowExecutionResultStatusCompleted WorkflowExecutionResultStatus = "completed"
	WorkflowExecutionResultStatusFailed    WorkflowExecutionResultStatus = "failed"
	WorkflowExecutionResultStatusPartial   WorkflowExecutionResultStatus = "partial"
)

// Defines values for WorkflowNodeType.
const (
	WorkflowNodeTypeCondition   WorkflowNodeType = "condition"
	WorkflowNodeTypeEmail       WorkflowNodeType = "email"
	WorkflowNodeTypeEnd         WorkflowNodeType = "end"
	WorkflowNodeTypeForm        WorkflowNodeType = "form"
	WorkflowNodeTypeIntegration WorkflowNodeType = "integration"
	WorkflowNodeTypeStart       WorkflowNodeType = "start"
)

// Condition Condition parameters for workflow execution
type Condition struct {
	// Operator Comparison operator for condition evaluation
	Operator ConditionOperator `json:"operator"`

	// Threshold Threshold value for comparison
	Threshold float32 `json:"threshold"`
}

// ConditionOperator Comparison operator for condition evaluation
type ConditionOperator string

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// ExecutionStep defines model for ExecutionStep.
type ExecutionStep struct {
	// Description Description of what was executed
	Description *string `json:"description,omitempty"`

	// Error Error message if the step failed
	Error *string `json:"error,omitempty"`

	// Label Display label of the node
	Label *string `json:"label,omitempty"`

	// NodeId ID of the executed node
	NodeId string `json:"nodeId"`

	// Output Output data from this step
	Output *map[string]interface{} `json:"output,omitempty"`

	// Status Execution status of this step
	Status ExecutionStepStatus `json:"status"`

	// Type Type of the node
	Type string `json:"type"`
}

// ExecutionStepStatus Execution status of this step
type ExecutionStepStatus string

// NodeData defines model for NodeData.
type NodeData struct {
	// Description Description of what this node does
	Description *string `json:"description,omitempty"`

	// Label Display label for the node
	Label *string `json:"label,omitempty"`

	// Metadata Additional metadata for the node
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// Position defines model for Position.
type Position struct {
	// X X coordinate
	X *float32 `json:"x,omitempty"`

	// Y Y coordinate
	Y *float32 `json:"y,omitempty"`
}

// Workflow defines model for Workflow.
type Workflow struct {
	// Description Description of the workflow
	Description *string `json:"description,omitempty"`

	// Edges List of edges connecting the nodes
	Edges *[]WorkflowEdge `json:"edges,omitempty"`

	// Id Unique identifier for the workflow
	Id openapi_types.UUID `json:"id"`

	// Name Name of the workflow
	Name *string `json:"name,omitempty"`

	// Nodes List of nodes in the workflow
	Nodes *[]WorkflowNode `json:"nodes,omitempty"`
}

// WorkflowEdge defines model for WorkflowEdge.
type WorkflowEdge struct {
	// Animated Whether the edge should be animated
	Animated *bool `json:"animated,omitempty"`

	// Id Unique identifier for the edge
	Id string `json:"id"`

	// Label Label displayed on the edge
	Label *string `json:"label,omitempty"`

	// LabelStyle CSS style properties for the edge label
	LabelStyle *map[string]interface{} `json:"labelStyle,omitempty"`

	// Source Source node ID
	Source string `json:"source"`

	// SourceHandle Source handle identifier (for conditional nodes)
	SourceHandle *string `json:"sourceHandle,omitempty"`

	// Style CSS style properties for the edge
	Style *map[string]interface{} `json:"style,omitempty"`

	// Target Target node ID
	Target string `json:"target"`

	// Type Type of edge
	Type *string `json:"type,omitempty"`
}

// WorkflowExecutionInput Input data for workflow execution
type WorkflowExecutionInput struct {
	// Condition Condition parameters for workflow execution
	Condition *Condition `json:"condition,omitempty"`

	// FormData Form data from user input - flexible map to support different workflows
	FormData *map[string]interface{} `json:"formData,omitempty"`
}

// WorkflowExecutionResult defines model for WorkflowExecutionResult.
type WorkflowExecutionResult struct {
	// ExecutedAt Timestamp when the workflow was executed
	ExecutedAt time.Time `json:"executedAt"`

	// Status Overall execution status
	Status WorkflowExecutionResultStatus `json:"status"`

	// Steps Execution details for each step
	Steps []ExecutionStep `json:"steps"`
}

// WorkflowExecutionResultStatus Overall execution status
type WorkflowExecutionResultStatus string

// WorkflowNode defines model for WorkflowNode.
type WorkflowNode struct {
	Data *NodeData `json:"data,omitempty"`

	// Id Unique identifier for the node
	Id       string    `json:"id"`
	Position *Position `json:"position,omitempty"`

	// Type Type of the node
	Type WorkflowNodeType `json:"type"`
}

// WorkflowNodeType Type of the node
type WorkflowNodeType string

// ExecuteWorkflowJSONRequestBody defines body for ExecuteWorkflow for application/json ContentType.
type ExecuteWorkflowJSONRequestBody = WorkflowExecutionInput

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get workflow by ID
	// (GET /workflow/{id})
	GetWorkflow(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Execute a workflow
	// (POST /workflow/{id}/execute)
	ExecuteWorkflow(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Get workflow by ID
// (GET /workflow/{id})
func (_ Unimplemented) GetWorkflow(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Execute a workflow
// (POST /workflow/{id}/execute)
func (_ Unimplemented) ExecuteWorkflow(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetWorkflow operation middleware
func (siw *ServerInterfaceWrapper) GetWorkflow(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorkflow(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ExecuteWorkflow operation middleware
func (siw *ServerInterfaceWrapper) ExecuteWorkflow(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteWorkflow(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workflow/{id}", wrapper.GetWorkflow)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workflow/{id}/execute", wrapper.ExecuteWorkflow)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
